---
tags: [java/基础知识]
title: 加权轮询算法
created: '2020-07-21T06:55:23.439Z'
modified: '2021-03-04T06:25:46.341Z'
---

# 加权轮询算法

网上有很多例子，都是抄来抄去的，也都说的不是很清楚。给刚开始学习的时候带来很大困扰。所以我尝试自己来解释下。

## 轮询算法
说加权轮询之前，要先说下普通轮询的算法。普通轮询思路想起来挺简单，比如你有一个list，里面放的是{a,b，c}。通过轮询算法来输出a,b,c,a,b,c 这种，直观的写法就会是这样的（伪代码）。
```
//初始化下标
int index = 0;
//初始化列表
list = {a,b,c};
do{
    //下标取余
    int i = index%list.size();
    print(list.get(i));
    //下标加1
    index=index+1;
}while(true);
```
但是这样会有一个问题，i 会不停的增加，这样是不太好的，更好的方法是，当i=list.size()的时候。把i重置为0。这样也能实现，但是明显不够优雅。所以现在普遍采用的方式是这样的。
```
int index = 0;
list = {a,b,c};
do{
    index = （index+1）%list.size();
    print(list.get(index));
}while(true);

```
1. 先设置 index = list.size()-1.这样当第一次执行到index+1的时候正好就等于list.size()，所以这时候对index进行取余操作，得到的下标就是0.
2. 然后把index+1取余再赋值给index，这样当第二次循环开始阶段index就是0，index+1取余，取到的下标就是1，同理再第二次循环取到的就是2，如此循环下去
3. 当index = list.size()-1的时候就又回到了第一步，index会被重置为0。这样就不存在无限增加的问题了。

#### 平滑的加权轮询
普通的加权轮询，会导致分布不均匀的情况，比如 a:5 ,b:1,c:1。输出的结果是aaaaabc,所以我们需要考虑更加平滑的算法。
具体描述如下：
1. 初始每个对象都有一个权重weight，和一个当前权重currentWeight。另外再有一个变量记录所有权重的总和total。
2. 选出当前权重最大的对象返回出去，并且把当前对象的currentWeight减去total。
3. 所有对象的currentweight，再叠加上自身的weight
4. 循环2，3即可
我们以{a:3,b:1,c:1}做为例子列出每次循环执行结果。

循环次数|当前权重|返回对象|选中后权重
-|-|-|-
1|{3,1,1}|a|{-2,1,1}
2|{1,2,2}|b|{1,-3,2}
3|{4,-2,3}|a|{-1,-2,3}
4|{2,-1,4}|c|{2,-1,-1}
5|{5,0,0}|a|{0,0,0}
6|{3,1,1}|a|....

可以看出

