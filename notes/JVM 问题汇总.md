---
tags: [java/jvm]
title: JVM 问题汇总
created: '2020-06-09T09:01:55.951Z'
modified: '2020-06-12T09:15:59.701Z'
---

# JVM 问题汇总

#### 请说下jvm的主要组成部分以及其作用。
jvm是运行在操作系统之上的一个系统，它由四部分组成，包括两个子系统和两个组件。两个子系统分别是，类加载子系统，和执行引擎。两个组件分别是运行时数据区和本地方法接口。其中，类加载子系统负责把类加载到运行时数据区的方法区，它只负责加载复合jvm规范的文件，并不会校验文件是否可执行。而执行引擎又包含即时编译器和垃圾回收器。运行时数据区就是我们通常说的jvm内存模型简称JMM，本地方法接口，负责和本地方法库进行交互。当类加载的时候，首先会把java代码转化为字节码加载到内存中，执行引擎负责调用本地接口把字节码转化为机器可识别的机器语言。

#### 请说一下运行时数据区。
java虚拟机在运行的时候，会把它管理的内存划分为五个区域。方法区，堆，虚拟机栈，本地方法栈，程序计数器。其中方法区和堆是跟随虚拟机进程启动和关闭创建和销毁的，而虚拟机栈，本地方法栈和程序计数器是线程独有的，跟线程的启动关闭保持同步。其中方法区主要用来存储已经加载的类信息，静态变量，即时编译后的代码等数据，堆主要用来存储所有的实例对象，虚拟机栈，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。本地方法栈，类似于虚拟机栈，不过是服务本地方法的。程序计数器是当前线程所执行字节码的行号指示器，根据这个值来决定下一行需要执行的字节码指令。

#### 请说一下堆和栈的区别
堆的物理地址是不连续的，速度慢一些，而栈的物理地址是连续的，所以速度比较快。堆存放的是实例对象和数组，更关注的是数据的存储，而栈存放的的是，局部变量，操作数栈，返回结果。更加关注方法的执行。垃圾回收是针对堆的，栈不需要进行垃圾回收。另外由于堆是不连续的，所以大小是在运行时确认的，大小并不固定，而栈是在连续的，所以分配的内存大小是固定的。还有堆是整个应该用共享的，栈是线程独享的。

#### 请说一下堆的组成部分
堆在逻辑上有，新生代，老年代，元空间组成。而物理上其实只有新生代和老年代。其实就是hotspot上把GC分代扩展至方法区，或者说使用元空间。新生代又分为Eden区和survivor0 和 survivor1。

#### 请说一下虚拟机new对象的过程。
1.先加载。判断类是否加载了，如果没有加载就去加载。2.为对象分配内存空间，这时候需要根据内存是否规整来区分，对于规整的内存使用指针碰撞，对于不规整的内存使用空闲列表方式，而内存是否规程主要看GC是否会压缩整理。在分配内存的时候还需要处理并发问题，现在有两种解决方案，第一个是同步处理，通过CAS+失败重试保证操作原子性，第二种是通过TLAB，本地线程分配缓冲，就是把内存分配动作划分在不同的空间之中，就是每个线程预先在内存中分配一小块内存。当TLAB用完分配新的TLAB的时候再同步。3.对内存空间进行初始化操作，然后设置对象头等信息。对象头包括markworld和元数据指针，其中markworld是对象运行时的信息，比如hash值，GC年龄分代，锁状态等。元数据指针就是指向方法区的类结构信息。4.执行init方法，调用构造函数，并对成员变量初始化。

#### 请问对象是如何访问到的
java程序通过jvm栈上的引用来访问到堆中具体的对象。目前主流方式有两种。句柄和指针。所谓的指针指的就是，引用直接指向对象。现在hotspot就是采用的这种实现。这种实现的好处是，直接就能访问到对象比较快。句柄的话，其实是引用指向了句柄，再通过句柄指向对象。这样的好处是，当垃圾回收改变了对象的内存地址的时候，只需要改变句柄的指向，不需要改变引用的指向。

#### 请说一下类的加载过程
一个类从加载包括五个阶段，加载，链接，初始化，使用，销毁。其中加载指的是把class文件通过二进制流的方式读取到虚拟机并转化为运行时的数据结构放在方法区，链接阶段会验证类的格式是否正确，并且为静态变量分配内存并初始化一个默认值，然后把符号引用替换为直接引用。初始化阶段会执行类构造器，类构造器指的是静给态变量赋值和执行静态代码块。然后就是等待被使用，一直到虚拟机关闭的时候会销毁。

#### 请说一下双亲委派机制
java自带的加载器有三个从上到下依次是bootstrap，ext，app。其中bootstrap主要负责加载jdk，lib包下面的jar和class，ext负责加载jdk中ext包下面的jar和class，app主要负责加载classpath下面的jar和class。所谓的双亲委派指的是当一个类需要被加载的时候，先自下而上的查找，如果能查找到就直接使用，如果查找不到就自上而下加载。这样的好处主要是为了安全，保证优先加载jdk自带的类文件而不是同包名同类名的自定义类文件。

#### 说一下你的native的了解
native是一个关键字，有native关键字的方法在java代码中只有声明没有实现，具体实现是的第三方函数库，而方法的执行是在本地方法栈中。

#### 请说一下GC的四大算法
#### 请说一次GC的四大收集器




