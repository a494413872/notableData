---
tags: [java/jvm]
title: JVM 问题汇总
created: '2020-06-09T09:01:55.951Z'
modified: '2020-06-18T03:34:37.807Z'
---

# JVM 问题汇总

#### 请说下jvm的主要组成部分以及其作用。
jvm是运行在操作系统之上的一个系统，它由四部分组成，包括两个子系统和两个组件。两个子系统分别是，类加载子系统，和执行引擎。两个组件分别是运行时数据区和本地方法接口。其中，类加载子系统负责把类加载到运行时数据区的方法区，它只负责加载复合jvm规范的文件，并不会校验文件是否可执行。而执行引擎又包含即时编译器和垃圾回收器。运行时数据区就是jvm虚拟机在执行java程序的时候会把数据分区存储，本地方法接口，负责和本地方法库进行交互。当类加载的时候，首先会把java代码转化为字节码加载到内存中，执行引擎负责调用本地接口把字节码转化为机器可识别的机器语言。

#### 请说一下运行时数据区。
java虚拟机在运行的时候，会把它管理的内存划分为五个区域。方法区，堆，虚拟机栈，本地方法栈，程序计数器。其中方法区和堆是跟随虚拟机进程启动和关闭创建和销毁的，而虚拟机栈，本地方法栈和程序计数器是线程独有的，跟线程的启动关闭保持同步。其中方法区主要用来存储已经加载的类信息，静态变量，即时编译后的代码等数据，堆主要用来存储所有的实例对象，虚拟机栈，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。本地方法栈，类似于虚拟机栈，不过是服务本地方法的。程序计数器是当前线程所执行字节码的行号指示器，根据这个值来决定下一行需要执行的字节码指令。

#### 请说一下运行时数据区和内存模型JMM的区别
运行时数据区，是虚拟机在运行时将数据分区存储，强调的是对空间的划分。而java内存模型JMM，描述了java多线程之间的通信方式，采用的是内存共享的通信方式。在JMM中，每个线程都有自己独立的工作内存，所有线程共享主内存，当线程访问变量的时候会先从主内存复制到工作内存，然后再去访问，当线程需要改变变量的值的时候，也会先修改工作内存然后刷新到主内存之中。

#### 请说一下happens-before
程序为了提高性能，编译器和处理器经常会对指令进行重新排序。happens-before就是定义一些规则来保证指令重排不会对最终结果产生影响。包括，程序次序规则，也就是说一段程序在单线程中执行的结果是有序的，指令重排不应该影响。锁定规则，一个锁处于锁定状态一定要先解锁再加锁。volatile变量规则，一个对volatile的写，一定发生在后续对这个变量的读。传递性，如果A happens-before B，B happens-before C，那么A happens-before C。

#### 请说一下堆和栈的区别
堆的物理地址是不连续的，速度慢一些，而栈的物理地址是连续的，所以速度比较快。堆存放的是实例对象和数组，更关注的是数据的存储，而栈存放的的是，局部变量，操作数栈，返回结果。更加关注方法的执行。垃圾回收是针对堆的，栈不需要进行垃圾回收。另外由于堆是不连续的，所以大小是在运行时确认的，大小并不固定，而栈是在连续的，所以分配的内存大小是固定的。还有堆是整个应该用共享的，栈是线程独享的。

#### 请说一下堆的组成部分
堆在逻辑上有，新生代，老年代，元空间组成。而物理上其实只有新生代和老年代。其实就是hotspot上把GC分代扩展至方法区，或者说使用元空间。新生代又分为Eden区和survivor0 和 survivor1。

#### 请说一下虚拟机new对象创建的过程。
1.先加载。判断类是否加载了，如果没有加载就去加载。2.为对象分配内存空间，这时候需要根据内存是否规整来区分，对于规整的内存使用指针碰撞，对于不规整的内存使用空闲列表方式，而内存是否规程主要看GC是否会压缩整理。在分配内存的时候还需要处理并发问题，现在有两种解决方案，第一个是同步处理，通过CAS+失败重试保证操作原子性，第二种是通过TLAB，本地线程分配缓冲，就是把内存分配动作划分在不同的空间之中，就是每个线程预先在内存中分配一小块内存。当TLAB用完分配新的TLAB的时候再同步。3.对内存空间进行初始化操作，然后设置对象头等信息。对象头包括markworld和元数据指针，其中markworld是对象运行时的信息，比如hash值，GC年龄分代，锁状态等。元数据指针就是指向方法区的类结构信息。4.执行init方法，调用构造函数，并对成员变量初始化。

#### 请问对象是如何访问到的
java程序通过jvm栈上的引用来访问到堆中具体的对象。目前主流方式有两种。句柄和指针。所谓的指针指的就是，引用直接指向对象。现在hotspot就是采用的这种实现。这种实现的好处是，直接就能访问到对象比较快。句柄的话，其实是引用指向了句柄，再通过句柄指向对象。这样的好处是，当垃圾回收改变了对象的内存地址的时候，只需要改变句柄的指向，不需要改变引用的指向。


#### 请说一下类的加载过程
一个类从加载包括五个阶段，加载，链接，初始化，使用，销毁。其中加载指的是把class文件通过二进制流的方式读取到虚拟机并转化为运行时的数据结构放在方法区，链接阶段会验证类的格式是否正确，并且为静态变量分配内存并初始化一个默认值，然后把符号引用替换为直接引用。初始化阶段会执行类构造器，类构造器指的是静给态变量赋值和执行静态代码块。然后就是等待被使用，一直到虚拟机关闭的时候会销毁。

#### 请说一下双亲委派机制
java自带的加载器有三个从上到下依次是bootstrap，ext，app。其中bootstrap主要负责加载jdk，lib包下面的jar和class，ext负责加载jdk中ext包下面的jar和class，app主要负责加载classpath下面的jar和class。所谓的双亲委派指的是当一个类需要被加载的时候，先自下而上的查找，如果能查找到就直接使用，如果查找不到就自上而下加载。这样的好处主要是为了安全，保证优先加载jdk自带的类文件而不是同包名同类名的自定义类文件。

#### 说一下你的native的了解
native是一个关键字，有native关键字的方法在java代码中只有声明没有实现，具体实现是的第三方函数库，而方法的执行是在本地方法栈中。


#### 你是否做过内存调优
我在自己的服务器上做过调优，当时之所以想进行内存调优是通过jstat发现GC比较频繁，具体调优过程就是先通过jps获取当前java应用进程的id。然后通过jinfo 查看虚拟机的配置信息。当时我内存资源比较紧张所以配置的堆内存是128的，结果就是Eden区很快就满了，就触发了YoungGC，YoungGC多了老年代增长也很快，相应的Full GC也就变快了。所以当时的解决方案是，通过Xmx和Xms稍微加大了堆内存，然后通过调整NewRatio和SuvivorRatio，让刚才添加的堆内存被分配到Eden区。这样同样的访问量，Eden区变满的速度明显变慢，相应的有很多对象都在新生代被回收掉了，老年代增长的速度也就变慢了，Full GC的数量也明显减少。对了，当时还手动指定了UseSerailGC，和MaxTenuringThreshold=15。前者主要是服务器资源紧张，访问量又不大，所以越简单越好。后者主要是保证对象在新生代多待一段时间，虽然说默认的也是15，但是感觉还是设置上比较放心，所以就加上了。

#### 如何判断对象应该被回收
一般有两种方式，引用计数器法，可达性分析算法。为每一个对象创建一个计数器，被引用一次加一，被释放-1.一直到0表示可以被回收。另一种叫做可达性分析算法。从GC Roots开始向下搜索，搜索过的路径被称为引用链，当一个对象到达GC Root没有任何引用链，就说明可以被回收。事实上第一种方式基本没有在使用，因为很难解决循环引用的问题。现在的jvm中基本都是用的可达性分析算法。

#### 请说一下GC的三大算法
1.标记清除算法。2.复制算法。3. 标记整理算法。标记清除算法是所有算法的基础，分为两个阶段。标记阶段，标记出可回收对象，清除阶段回收被标记的对象。由于回收之后会产生大量碎片就产生了复制算法。复制算法会准备两块一样大的内存，遍历一边，把所有存活对象移动到另外一块内存中。新生代就采用的这个算法。由于老年代对象存活的比较久，也不太可能准备两块内存，所以采用标记整理算法，在标记可回收对象之后将所有存活对象压缩在一端，然后对端边界之外的内存进行回收。
JVM采用分代收集算法，对于不同的内存区域选择不同的算法，对年轻代采用复制算法，老年代采用 标记清除和标记整理


#### 请描述一下GC的过程
分代回收器有两个分区，新生代和老年代，新生代和老年代比例是1:2.新生代又分为Eden，s0,s1。比如是8:1:1
对象生成一般会在Eden区，当Eden区满了之后，虚拟机会触发minorGC。回收掉无用对象，然后把幸存对象复制到s0,等到下次Eden区满了之后，触发第二次GC，把Eden存活对象和s0里面的对象都移动到s1，然后对象的年龄加一。然后交换S0和S1。对象经历过15次的s0到s1交换仍然幸存，会被移动到老年代。等到老年代也满了会触发full GC，对老年代进行整理。如果full GC之后仍然无法进行对象的保存，会产生OOM异常。

#### 请说一次GC的几种收集器
新生代的收集器有三种，这三种采用的都是复制算法，第一种叫serail，单线程，第二种叫ParNew，其实就是Serail的多线程版本。第三种Parallel Scavenge，主要是为了提高吞吐量，减少GC次数，比较适合用户交互较少的场景。老年代也有三种，serail old，老年代单线程收集器采用的标记整理算法。Parallel Old 基本是Parallel Scavenge的老年代版本。CMS 采用标记清理算法，cms算法以高并发低停顿时间为目的。还有最后一种是G1，G1是针对整个堆的，整体上采取的是标记整理算法但是局部采用的是复制算法，同时满足低暂停时间，高吞吐的一种垃圾回收器。事实上在JVM选择垃圾回收器的时候，除了G1之外其他回收器都是混合使用的。比如配置成-XX:+UseSerialGC代表新生代使用serail，老年代使用serail old，配置成-XX:+UseParNew表示新生代使用parNew，老年代使用serailOld。配置成-XX:UseParallelGC 是新生代使用Parallel Scavenge老年代使用serailOld，如果再加上-XX:UseParallelOldGC，表示老年代使用Parallel old。配置成-XX:+UseConcMarkSweepGC,就是CMS，这时候新生代使用的是parNew，老年代使用的是CMS，并且当CMS出错的时候会采用Serial old做为后备，这个主要是为了解决CMS产生的碎片。最后就是-XX:+UseG1GC,表示使用G1收集器。

#### 请说一下CMS具体流程
CMS主要经过四个阶段，1.初始标记，2.并发标记，3.重新标记，4.并发清理。其中初始标记和重新标记都会触发stw。其中初始标记仅仅标记一下GC roots直接关联对象非常快，而并发标记是搜索引用链虽然比较慢但是不中断程序，重新标记是对并发标记阶段的变更进行一个补偿，所以也是很快的。最终并发清理也是不会中断程序，所以这样就实现了低暂停时间的目的。但是会产生碎片，碎片太多导致内存无法使用，会报错，然后会切换为serail old来进行整理。

#### 请说一下你对G1的了解
我觉得G1算是对CMS的一个升级，和CMS不同的是它把内存分为一个个的Region，这样虽然整体看起来是采用的标记整理算法，但是在region的角度来看，采用的是复制算法，所以其实并不会产生内存碎片。另外G1的一个特单是可以允许用户设定应用暂停的时间。因为G1不需要对整个内存区域进行收集，可以根据用户设定的时间来估算出自己需要收集的Region，当然尽量优先垃圾占比指比较高的region。G1的缺点是并不适合小内存场景，内存过小的话部分回收根本不够用，始终需要进行整个堆的回收，而由于算法复杂度又比较高，可能比其他收集器效率更差。








