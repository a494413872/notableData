---
tags: [java/杂记]
title: 架构笔记
created: '2020-06-28T07:45:39.888Z'
modified: '2020-07-06T11:32:53.456Z'
---

# 架构笔记

#### 系统与子系统
- 系统是一系列有关联的个体组成，根据某种规律运作，完成独立个体不能完成工作的群体。
- 子系统也符合系统的观念，但是比较小，大多是系统的一部分

#### 模块与组件
- 模块是一套一致并且有关联的软件组织
- 而组件是独立的软件单元。
- 其实是从不同角度拆分的结果。比如一个学生管理系统，可以拆分为，登录注册模块，个人成绩模块，个人信息模块。按组件来拆分可以拆分为nginx，web服务器，mysql。

#### 框架与架构
- 框架是组件的规范，并且提供了规范要求基础功能的软件产品。比如springMVC它是一个MVC的框架，是一个提供了符合MVC标准的软件产品。
- 架构是指软件系统的基础结构，创造这些结构的标准，以及对这些结构的描述。

#### 架构设计的原则
1. 合适原则
    > 根据业务场景选择最合适的方案
2. 简单原则
    > 方案要尽可能简单，能降低成本，并且已于完成
3. 演化原则
    > 软件架构需要根据业务需求的变化进行演化

#### 架构设计的流程
1. 有的放矢--识别复杂度
    > 架构的目的就是为了解决系统的复杂性，要先识别复杂度，才能给出正确的结果。复杂度主要来源是高性能，高扩展，高可用。但是主要是其中一个到两个互相影响。
2. 按图索骥--设计备选方案
    > 确定了复杂度，设计就有了目标，事实上大部分设计都是基于现有技术进行的组合，也就是技术选型。而设计的时候最好设计3到5个备选方案，这样考虑的会更全面，也能避免因为只有一个方案而产生的的过度辩护。
3. 深思熟虑--评估和选择备选方案
    > 评估方案的时候，要根据1合适原则，2简单原则。维度一般从性能，复杂度，成本，扩展性，可用性几个维度进行评估。
4. 精雕细琢--详细方案设计
    > 比如用ng的话，是轮询，还是hash。这架构师要对所使用的技术有深度的理解。
### 高性能架构模式

#### 存储高性能
1. 关系数据库
    1. 读写分离（分散读写压力）
        > 1.服务器搭建主从集群，1主已从，1主多从都可以。2.主写从读。3.主机通过数据同步复制数据，每台服务器保存所有数据。4.业务代码来实现读写分离。
    2. 分库分表
        - 业务分库（分散存储压力）
            > 比如订单库和用户库分散到不同服务器。带来的问题有。1.jion问题：不同库无法关联查询。2.事物问题：必须引入分布式事物，但是性能太低。3.成本问题：机器多成本高
         - 分表（解决单表过大问题）
            - 垂直切分
                > 不同字段切分到不同表
            - 水平切分
                > 不同的记录分散到不同的表，复杂度更高。需要考虑几个重点：1.路由（范围路由，hash路由，配置路由），2.join 3.count（count相加，记录数表）4.orderby
      3. 实现方法
          - 程序代码封装
              > 实现更加自由，比较出名的有淘宝的TDDL
          - 中间件封装
              > 用一个中间件来代理数据库。比如mysql官方推荐的MySQL Router。奇虎360基于mysql-proxy实现的atlas。
2. NoSQL
    > 常见的有4种，1.k-v存储，解决关系数据库无法存数据结构问题，代表Redis。2. 文档数据库，解决数据库强schema约束问题，代表MongoDB。3.列式数据库：解决关系数据库大数据场景下的I/O问题，以HBase为代表。4.全文搜索引擎：解决关系数据库全文搜索新能问题，以Elasticsearch为代表。
3. 缓存
    > 把重复使用的数据放入内存，一次生成多次使用。
    - 缓存穿透
        > 查询不存在的数据，因为不存在不会被缓存所以会查库。
    - 缓存雪崩
        > 缓存失效之后，多个线程同时去访问数据库，然后再生成缓存。解决方案有1.更新锁，只允许一个线程去访问数据库更新缓存，其他线程等待或者返回默认值。2.后台更新，缓存永不过期，后台定时去更新缓存。后台更新有可能导致缓存丢失，这时候需要一定补偿机制。1.定时查询，定时去访问看看缓存还在不在，2.缓存丢失发消息，接受消息后，再判断缓存是否存在然后不存在再更新。
    - 缓存热点
        > 对于热点缓存的访问服务器压力也很大，解决方案是通过对缓存进行复制，然后分散存储在不同服务器，访问也分发到不同服务器。

#### 计算高性能
1. 单服务器高性能
    > 服务器高性能主要是两个方面1.如何管理连接，2.如何处理请求。 这两点对应的是IO模型（阻塞，非阻塞，同步，异步）和线程模型（单进程，多进程，多线程）。
    1. PPC processor per connection。每个连接开启一个进程处理
    2. prefork 提前开启进程。为了解决开启进程比较慢的问题
    3. TPC thread per connection。每个连接开启线程处理
    4. prethread 提前开启线程。
    5. reactor 多路复用技术+进程池。用来解决上面几种方式带来的问题。
    6. proactor 实现异步IO，linux下支持不好。
2. 集群高性能
    > 集群本质就是通过增加更多服务器提升系统整体的计算能力。高性能集群复杂度主要体现在任务分配器上，也就是负载均衡器。
    1. 负载均衡分类
        - DNS负载均衡 根据ip分配到本地服务器上，粒度比较粗，通常由域名商实现，比较简单。
        - 硬件负载均衡 通过单独设备来负载均衡，成本较高。 F5和A10
        - 软件负载均衡 常见Nginx和LVS。成本低，但是性能比起硬件差。ng是万级，5万/秒 LVS 十万级，80万每秒. F5的话百万级，两百万到八百万。
    2. 负载均衡架构
        > 主要指的是不同不通负载均衡方案的混合使用。
    3. 负载均衡算法
        1. 任务平分类，不一定是完全平分也可以是权重或者比例上的平分。
        2. 负载均衡类，根据负载分配，负载可以是cpu，io,连接数，网卡吞吐等等。
        3. 性能最优类，根据响应时间
        4. hash类，根据任务中关键信息进行hash，相同结果的分配在同一台机器上。
3. 高可用架构
    1. CAP
        > CAP指在一个分布式系统中（互相连接并且共享数据的节点集合），当涉及到读写操作时，只能保证，一致性，可用性，分区容错性三者中的两个，另一个必须被牺牲。由于不能保证网络一定畅通，所以分区是一定会出现的，所以通常的选择是ap或者cp。比如当出现分区现象的时候，我们就让系统down机，这就是cp牺牲了a。正常情况下网络是不会出现问题的所以，不考虑P的情况下是可以满足CA的，只是当真的出现P的时候如何处理。
        - 一致性，对某个指定的客户端来说，读操作能够返回最新写操作的数据
        - 可用性，非故障节点，在合理的时间内返回合理的相应。
        - 分区容错性，当出现网络分区后系统能有继续履行职责。网络分区只的是网络不通的状况。
    2. ACID
        >是数据库为了保证事物的正确性提出的一个理论。
          - 原子性
          - 一致性
          - 隔离性
          - 持久性
    3. BASE
        > 是AP方案的延伸
          - BA 基本可用
          - S 软状态
          - E 最终一致性
#### FMEA
FMEA failure mode and effects analysis，故障模式与影响分析

#### 存储高可用
>对任何一个高可用存储方案，都应该考虑以下几个问题。1.数据如何复制，2.各个节点的职责是什么，3.如何对应复制延迟，4.如何对应复制中断。
1. 主备复制
>备份机存储数据，并不读取，只是做灾难恢复。
2. 主从复制
>从机负责读取，主机负责写入。
3. 主备交换与主从交换
> 当主机down机之后，把从机器切换为主机。可以手动可以自动。

常见架构
  1. 互连式
  >主备之间传递状态
  2. 中介式
  >主备之间引入第三方中介，主备通过中介传递状态信息，中介来指定主备。比如可以用zookeeper座位中介。
  3. 模拟式
  >主备之间没有状态传递通道，而是备机通过模拟读写来判断主机状态。
4. 主主复制
>两台都是主机，互相复制数据，客户端随便发送读写给哪台机器都行。对于不能双向复制的数据不合适，比如id，比如库存。
5. 数据集群
    > 数据量过大，一台主机存不下，就需要使用集群了。
    1. 数据集中集群
        >主机单机，备机集群
    2. 数据分散集群
        >多个服务器组成一个集群，每台服务器存储一部分数据，并且备份一部分数据。这时候就需要考虑数据分散的算法。从1.均衡性，2.容错性，3.可伸缩性。上来考虑。Hadoop实现就是有一个独立服务负责分配数据。ES的实现是选举一台服务器做数据分配。
    3. 分布事物算法
        1. 2PC 二阶段提交
            > 算法由两个阶段组成，commit请求和commit提交。一个节点座位调节者，其他节点做为参与者。第一阶段，调节者发起请求，参与者写入日志，并返回Yes/No，第二阶段，收到所有Yes，再发送commit请求。参与者收到commit，提交事务并返回ACK。如果有No，协调者就发送就rollback请求。可能出现单点故障，比如阶段一之后协调者挂了，参与者就会陷入阻塞。

          2. 3PC 三阶段提交
              > 在二阶段中间插入了一个准备阶段。第一阶段改为发送cancommit，参与者判断自己是否可以提交，返回yes/no。协调者收到所有YES，先发送precommit给参与者，参与者收到之后开启事物记入日志。然后返回ACK。协调者收到所有消息后再发送doCommit消息。参与者收到后提交事物并返回have commit。 
    4. 分布式一致性算法 
        > 分布式一致性算法主要是保证同一份数据在多个节点上的一致性，满足CAP中的CP。其中最有名的是Paxos算法。这个算法是理论上的算法，实际上的实现都是Paxos算法的不完整版。
          1. Raft
              > 通过强化Leader作用实现的。复制是通过各个节点复制具体操作，然后节点自身执行。
          2. ZAB
              > Zookeeper Atomic Broadcast Protocol。也是强化leader的作用。但是复制的时候是复制的执行结果。
  6. 数据分区
      >从地理的角度来设计高可用，避免一个城市的网络瘫痪造成的影响。将数据按照一定规则分区，每个分区存储一部分数据。一般从以下几个角度考虑
      1. 数据量
          > 数据大小决定分区规则复杂程度。例如mysql，假设一天能存五百GB，那么2TB就要4台复杂度，200T就是800台，而八百台每周两台故障，运维成本就非常高了。
      2. 分区规则
          >地理位置远近不同，包括洲际分区，国家分区，城市分区。
      3. 复制规则
          > 指的是数据如何复制，主要分为集中式，互备式，独立式。
          - 集中式，所有数据放在一个备份中心
          - 互备式，不同地区之间的服务器互相之间为对方备份
          - 独立式，每个地区服务器都在其他地区有单独备份。
#### 计算高可用
计算高可用，是指当部分硬件出问题时，系统仍然可以正常运行，通常说通过冗余来规避部分故障风险。高可用的设计关键点如下
- 哪些服务器可以执行任务
    > 1.每台都可以执行，2.特定的比如zk中的leader才能处理读写请求。
- 任务如何重新执行
    > 1.对于已经分配的任务即使失败也不管，只是保证新的任务能费配到其他非故障机器上执行。2.设计一个任务管理器来管理需要执行的任务，执行完成后要反馈结果给管理器，管理器根据反馈来决定是否重新分配任务。
1. 主备
    >主机执行所有任务，备机启动（温备）或者不启动（冷备），但是不处理任何任务，主机故障，先尝试修复主机，系统暂时不可用。回复不了手动升级备机为主机，并且添加新的备机。
2. 主从
    > 类似主备，只是会执行部分任务。
3. 对称集群
    > 所有机器都是一样的都可以执行所有任务，由任务分配器来分配任务。任务分配器负责发现故障机并切换任务分配。
4. 非对称集群
    > 以master-slave为例，部分机器是master才能提供所有服务，部分机器是slave提供部分服务。当master故障，从slave中重新指定一个master提供服务。
### 业务高可用
1. 异地多活
    > 异地就是地理上不同，多活就是指不同地理上位置上的系统都能够提供业务服务。无论客服访问那个地理位置上的服务器都能得到正确的业务。
    1. 异地多活架构
        - 同城异区
            > 搭建高速网络连接你放，打到近似一个机房的效果。
        - 跨城异地
            > 如何解决数据不一致。
        - 跨国异地 
            > 主要是先面不同地区用户提供业务，或者提供只读业务，架构设计要求不高。  
    2. 异地多活设计技巧
        - 保证核心业务异地多活，不需要所有的业务都多活
        - 核心数据最终一致性，保证最终一致性，不保证实时一致性
        - 采用多种数据同步手段，包括
            - 消息队列
            - 二次读取，A读不到读B
            - 存储系统异步，数据库同步机制
            - 回源读取，跟去id去插入源头读取数据
            - 重新生成
        - 只保持绝大部分用户的异地多活
    3. 异地多活设计步骤
        1. 业务分级
            > 按照一定标准进行业务分级，只为核心业务异地多活
        2. 数据分类
            > 挑选出核心业务后，分析相关数据，根据数据特征设计方案。
        3. 数据同步
            > 分析出数据特点后，根据不同方案进行数据同步。
        4. 异常处理
            > 问题发生时，避免少量数据异常导致整体业务不可用，问题回复后，将异常数据进行修正，对用户安抚弥补用户损失。
                1. 双通道同步，就是选择两种通道进行同步数据，只适合可以重复写入的数据。
                2. 同步和访问结合，这里访问指的是异地机房通过接口来进行数据访问。比如A,B两个异地机房，B机房分局路由规则判断当前用户属于A机房，去A机房读取用户数据。
                3. 日志记录，日志主要用于故障后数据恢复。
                4. 用户补偿，礼包啥的
2. 接口级的故障应对方案
    >异地多活主要应对机房故障，网络故障等，概率较小，实际上发生更多的是接口级故障，比如相应很慢，数据库压力过大拒绝服务，等等，一般有内部原因或者外部原因（黑客）导致。
    1. 降级
        >降级指的是将默写业务接口的功能降低，可以是只提供部分功能，也可以是停掉所有功能。比如论坛降级为只能看贴不能发帖。实现降级有以下几种方式。
            - 系统后门降级，提供URL访问相当于执行降级命令
            - 独立降级系统，把降级放到单独的系统实现比较复杂的管理。    

